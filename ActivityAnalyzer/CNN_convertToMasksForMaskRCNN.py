'''
####################################################################################################################################
##THIS SCRIPT IS DEPRECATED. IT SHOULD NO LONGER BE USED. INSTEAD JUST RUN CNN_DrawLabelsInImages.py WITH THE --mrcnn_format FLAG.##
####################################################################################################################################

This will take a set of images generated by CNN_DrawLabelsInImages.py and convert them into instance masks for the
Mask RCNN network. 

CNN_DrawLabelsInImages.py creates images where all the masks are value 255 (white) but the Mask RCNN network requires
a mask image where the first object in the mask has value 1, the second has value 2... etc.
If there is only one object in the image then this program will simply take the image and convert all non-zero values to 1.
If there is more than one object in the image then each object will need its own image generated using CNN_DrawLabelsInImage,
each image named sequentially, and this program will take each image and make one final mask image where each object is masked with its
appropriate value in the sequence.
    For example:
        Image1.png has 3 objects
        use CNN_DrawLabelsInImages.py to generate 3 files - Image1_mask_001.png, Image1_mask_002.png, Image1_mask_003.png
            Image1_mask_001.png should have a single mask that details only the first object in Image1
            Image1_mask_002.png should have a single mask that details only the second object in Image1
            Image1_mask_003.png should have a single mask that details only the third object in Image1
        This program will create a final image - Image1_mask_final.png, which has 3 object masks in it with values 1, 2, and 3 respectively.


***** NOTE: It is now possible to use CNN_DrawLabelsInImages.py to directly create images in the proper mask rcnn training format by passing the
         command line argument --mrcnn_format when running the file. That is now the preferred method rather than the method described above and
         and then using this program to reformat the images.
'''

import cv2
import numpy as np
from verifyDirlist import *
from roipoly_adf import *
import tkinter as tk
import tkinter.filedialog


def threshold_color(imgs):
    ## grab the image dimensions
    h = imgs[0].shape[0]
    w = imgs[0].shape[1]
    #d = imgs[0].shape[2]    

    print(f"Shape = {imgs[0].shape}")

    final_img = np.zeros(shape=imgs[0].shape)

    for y in range(0, h):
        for x in range(0, w):
            # threshold the pixel
            for mask_num in range(len(imgs)):    
                if imgs[mask_num][y, x] > 0:
                    final_img[y, x] = mask_num + 1
                    break
                else:
                    final_img[y, x] = 0
    
    return final_img


pimg = r'C:\Dropbox\FramesData\FramesForAnnotation\train\Renamed\PedMasks_original'

# Select the folder with the mask images in need of conversion
root = tk.Tk()
root.withdraw()
pimg = tk.filedialog.askdirectory(parent=root, initialdir=pimg, title='Please select the masks folder')

dimg, dshort = verifyDirlist(pimg,False,'.png')

images_to_open = []
multiple_masks = False
final_name = ""
for (imgname, short_name) in zip(dimg,dshort):
    try:
        # If the image ends in _### format then we assume it is part of a sequence of masks that need to be stitched together
        print(f"Trying: {short_name[-7:-4]}")
        int(short_name[-7:-4])
        multiple_masks = True
        images_to_open.append(cv2.imread(imgname,cv2.IMREAD_GRAYSCALE))
        final_name = imgname[:-7] + "final.png"
        continue
    except Exception:
        if multiple_masks: # Stitch together the previous images that were part of the same mask before doing the current image
            print(f"Found image sequence {short_name}")
            final_img = threshold_color(images_to_open)
            cv2.imwrite(final_name, final_img)

        multiple_masks = False
        images_to_open.clear()
        final_img = threshold_color([cv2.imread(imgname,cv2.IMREAD_GRAYSCALE)])
        final_name = imgname[:-4] + "_final.png"
        cv2.imwrite(final_name, final_img)

           
if multiple_masks: # The last image was part of a sequence, so stitch them together and threshold them
    print("found last image sequence")
    final_img = threshold_color(images_to_open)
    cv2.imwrite(final_name, final_img)
        





